#!/usr/bin/env bash
# === CONFIGURACI√ìN Y TRAMPAS DE ERROR ===
set -euo pipefail # manejo de errores: -e (salir inmediatamente), -u (variables no definidas), -o pipefail (fallar en pipelines)

# ESTA ES LA VARIABLE GLOBAL DEL NOMBRE DEL PROYECTO :3
PROJECT_NAME=""

# ESTA ES LA FUNCION DE LIMPIEZA :)))))
cleanup() {
    local exit_code=$?
    if [ "$exit_code" -ne 0 ] && [ -n "$PROJECT_NAME" ] && [ -d "$PROJECT_NAME" ]; then
        echo ""
        echo "=========================================================="
        echo "üí• ERROR detectado (c√≥digo $exit_code). Limpiando..."
        cd ..
        # EN ESTA PARTE SOLO ELIMINO SI EL DIRECTORIO FUE CREADO POR ESTE SCRIPT
        rm -rf "$PROJECT_NAME"
        echo "‚ùå Directorio '$PROJECT_NAME' eliminado para un intento limpio."
        echo "=========================================================="
    elif [ "$exit_code" -eq 0 ]; then
        # MENSAJE SI TODO SALE GOD
        echo ""
        echo "=========================================================="
        echo "Proyecto '$PROJECT_NAME' creado exitosamente. ¬°Listo para arrancar!"
        echo "Pasos a seguir:"
        echo "1. cd $PROJECT_NAME"
        echo "2. docker compose up --build"
        echo "3. Ejecuta 'air' en otra terminal para hot-reload (si lo instalaste)."
        echo "=========================================================="
    fi
    exit $exit_code
}

# EJECUTA LA FUNCION cleanup AL SALIR, SEA POR ERROR O NONESSSSS
trap cleanup EXIT

# ==================================
# 1. VALIDACI√ìN INICIAL
# ==================================

echo "=========================================================="
echo "Backend Go Inicializador: Fiber + PostgreSQL + Docker"
echo "=========================================================="

if [[ "$1" != "init" ]]; then
  echo "Comando no reconocido. Usa: $0 init"
  exit 1
fi
# ESTA PARTE VERIFICA SI GO ESTA INSTALADO :O
if ! command -v go &> /dev/null; then
    echo "Go no est√° instalado. Por favor inst√°lalo: https://go.dev/dl/"
    exit 1 # SALE EL ERROR >C
fi
echo "Go ya est√° instalado"

# ==================================
# 2. CONFIGURACI√ìN DEL PROYECTO
# ==================================

# VARIABLES QUE SE USARAN EN LA CONFIGURACION DEL PROYECTO
DB_USER="devuser"
DB_PASS="devpassword"
DB_NAME="myappdb"
APP_PORT="8080"
JWT_SECRET_DEFAULT="supersecretkey"

# VALIDA EL NOMBRE HASTA QUE ESTE ESTE CORRECTO
while true; do
    read -rp "Nombre del proyecto (solo letras, n√∫meros y guiones): " name_input
    
    if [[ "$name_input" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        PROJECT_NAME="$name_input"
        break
    else
        echo "Nombre inv√°lido. Usa solo letras, n√∫meros, guiones o guiones bajos."
    fi
done
# VALIDA QUE NO EXISTA YA UN DIRECTORIO CON ESE NOMBRE
if [ -d "$PROJECT_NAME" ]; then
    echo "El directorio '$PROJECT_NAME' ya existe. Cancela para evitar sobrescribir."
    exit 1
fi
# CREA EL DIRECTORIO Y SE MUEVE A EL
mkdir "$PROJECT_NAME"
cd "$PROJECT_NAME"
# INICIALIZA EL MODULO GO
echo "üß© Inicializando m√≥dulo Go ($PROJECT_NAME)..."
go mod init "$PROJECT_NAME"
# INSTALA LAS DEPENDENCIAS NECESARIAS
echo "üì¶ Instalando dependencias..."
go get github.com/gofiber/fiber/v2
go get golang.org/x/crypto/bcrypt
go get github.com/golang-jwt/jwt/v5
go get github.com/joho/godotenv
go get github.com/lib/pq
go mod tidy > /dev/null # LIMPIA EL GO.MOD Y GO.SUM PARA QUE NO TENGA COSAS RARAS

echo "üìÇ Estructura..."
# LA OPCION -p CREA DIRECTORIOS PADRE SI NO EXISTEN
# ESTA ES LA ESTRUCTURA QUE YO RECOMIENDO YA QUE ES MODULAR Y FACIL DE ENTENDER
# EN internal VAN COSAS QUE NO QUIERES QUE OTROS USEN (LOGICA DE NEGOCIO)
# EN pkg VAN COSAS QUE PUEDEN SER REUSADAS (UTILIDADES, CONFIGURACIONES, MIDDLEWARES)
# EN cmd VA EL PUNTO DE ENTRADA
# EN db VA LO RELACIONADO A LA BASE DE DATOS (ESQUEMA, MIGRACIONES, ETC)
mkdir -p internal/users/{routes, controller, repository, service, DTOs, model} \
     pkg/{config,middleware,utils} \
     cmd/server \
     db
# CREA EL ARCHIVO .gitignore 
echo "üìÑ Archivos base..."
cat <<EOF > .gitignore
# Dependencias
/vendor
# Binarios
/*.exe
/*.bin
/tmp
# Archivos de entorno
/.env
# Archivos de Air
/.air.toml
# Data de la BD
/db/data
EOF

# CREA EL ARCHIVO DE ESQUEMA DE LA BASE DE DATOS (POSTGRESQL)
# EN ESTE VIENE UNA TABLA DE USUARIOS DE EJEMPLO :3
# LA CUAL PUEDES CAMBIAR EL ARCHIVO ANTES DE LEVANTAR EL CONTENEDOR PARA ASI PODER TENER TU PROPIA ESTRUCTURA
cat <<EOF > db/schema.sql
-- Archivo de esquema inicial de la base de datos
-- Se ejecuta una sola vez al levantar el contenedor de PostgreSQL

CREATE TABLE IF NOT EXISTS users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);
EOF

# ==================================
# 3. GENERACI√ìN DE C√ìDIGO Y DOCKER
# ==================================

# MANEJOR DE EL .env
echo "üìÑ Configurando .env..."
# PREGUNTA SI QUIERE CONFIGURAR EL .ENV AHORA CON VALORES PERSONALIZADOS O DEJA LOS POR DEFECTO
read -rp "üí° ¬øQuieres ingresar tu URL de BD y palabra secreta JWT ahora? (y/n): " auto_env
# CREA LOS VALORES POR DEFECTO POR SI EL USUARIO NO QUIERE PERSONALIZAR
db_url_final="postgresql://${DB_USER}:${DB_PASS}@localhost:5432/${DB_NAME}?sslmode=disable"
jwt_secret_final="$JWT_SECRET_DEFAULT"
# SI EL USUARIO QUIERE PERSONALIZAR, PREGUNTA Y ACTUALIZA LAS VARIABLES
if [[ "$auto_env" == "y" || "$auto_env" == "Y" ]]; then
    read -rp "üì¶ URL de la base de datos (Ej: $db_url_final): " custom_db_url
    # SOLO SI EL USUARIO INGRESA ALGO, ACTUALIZA LA VARIABLE
    [ -n "$custom_db_url" ] && db_url_final="$custom_db_url"

    read -rp "üîë JWT Secret (Ej: $JWT_SECRET_DEFAULT): " custom_jwt_secret
    [ -n "$custom_jwt_secret" ] && jwt_secret_final="$custom_jwt_secret"
fi
# CREA EL ARCHIVO .env CON LAS VARIABLES NECESARIAS
cat <<EOF > .env
# Variables de la aplicaci√≥n
PORT=${APP_PORT}
JWT_SECRET=${jwt_secret_final}

# Variables de la base de datos
DB_URL=${db_url_final}
DB_USER=${DB_USER}
DB_PASS=${DB_PASS}
DB_NAME=${DB_NAME}
EOF


# UFF DOCKER :O
echo "üìÑ Archivo Dockerfile..."
cat <<EOF > Dockerfile
# Etapa 1: Build Stage
FROM golang:1.25-alpine AS builder

WORKDIR /app

COPY go.mod go.sum ./
RUN go mod download

COPY . .

# Construye la aplicaci√≥n. Aseg√∫rate de que el path coincida con tu estructura (./cmd/server)
RUN CGO_ENABLED=0 go build -o /server ./cmd/server

# Etapa 2: Runtime Stage
FROM alpine:latest
RUN apk --no-cache add ca-certificates

COPY --from=builder /server /server

# Expone el puerto por defecto de Fiber
EXPOSE 8080

# Comando para ejecutar la aplicaci√≥n
CMD ["/server"]
EOF

# UFF DOCKER X2 :O
echo "üìÑ Archivo docker-compose.yml..."
cat <<EOF > docker-compose.yml
services:
  # --- Servicio de la Base de Datos (PostgreSQL) ---
  db:
    image: postgres:16-alpine # Usar una imagen Alpine m√°s ligera y versi√≥n m√°s reciente
    container_name: ${PROJECT_NAME}_db
    restart: always
    environment:
      # Lee las credenciales del .env para no hardcodearlas
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PASS}
      POSTGRES_DB: ${DB_NAME}
    ports:
      - "5432:5432"
    volumes:
      - ./db/data:/var/lib/postgresql/data
      - ./db/schema.sql:/docker-entrypoint-initdb.d/schema.sql

  # --- Servicio de la Aplicaci√≥n Go (Backend) ---
  backend:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: ${PROJECT_NAME}_backend
    restart: unless-stopped
    env_file:
      - .env # Carga el .env local
    ports:
      - "${APP_PORT}:${APP_PORT}"
    depends_on:
      - db
    # **Importante:** Usar el nombre del servicio (db) como host
    environment:
      DB_URL: postgresql://${DB_USER}:${DB_PASS}@db:5432/${DB_NAME}?sslmode=disable
      # Necesitas redefinir las vars para que Fiber las use, aunque ya est√©n en .env
      PORT: ${APP_PORT}
      # JWT_SECRET: ${jwt_secret_final} # Si es necesario para pruebas
EOF

# ==================================
# 4. ARCHIVOS DE C√ìDIGO GO
# ==================================

# sqlparse ES UNA FORMA DE GENERAR CONSULTAS SQL DIN√ÅMICAMENTE SIN NECESIDAD DE USAR UN ORM
# OJO NO SE VA A QUEDAR PERO PARA PRINCIPIANTES QUE QUIERAS HACER COSAS RAPIDAS VA BIEN
# EN UN FUTURO IMPLEMENTARE GORM OOOUUU YEAH!!!!!
echo "üìÑ Generando pkg/utils/sqlparse.go..."
cat <<EOF > pkg/utils/sqlparse.go
package utils
//el sqlparse solo se ocupa para generar consultas sql de tipo insert y update
import (
  "fmt"
  "strings"
  "strconv"
)

// ParseInsertArray genera din√°micamente una consulta SQL de tipo INSERT
func ParseInsertArray(tableName string, data map[string]interface{}) (string, []interface{}) {
  columns := []string{}
  placeholders := []string{}
  values := []interface{}{}

  i := 1
  for key, value := range data {
    columns = append(columns, key)
    placeholders = append(placeholders, fmt.Sprintf("$%d", i))
    values = append(values, value)
    i++
  }

  // Genera la consulta SQL
  query := fmt.Sprintf("INSERT INTO %s (%s) VALUES (%s)", tableName, strings.Join(columns, ", "), strings.Join(placeholders, ", "))
  return query, values
}

// ParseUpdateArray genera una consulta SQL de actualizaci√≥n y una lista de valores
func ParseUpdateArray(table string, data map[string]interface{}, condition map[string]interface{}) (string, []interface{}) {
  setClauses := []string{}
  values := []interface{}{}
  i := 1

  // Construir las cl√°usulas SET
  for key, value := range data {
      if value != nil && value != "" { // Filtrar valores vac√≠os o nulos
          setClauses = append(setClauses, key+" = $"+strconv.Itoa(i))
          values = append(values, value)
          i++
      }
  }

  // Construir las condiciones WHERE
  whereClauses := []string{}
  for key, value := range condition {
      whereClauses = append(whereClauses, key+" = $"+strconv.Itoa(i))
      values = append(values, value)
      i++
  }

  // Generar la consulta SQL
  query := "UPDATE " + table + " SET " + strings.Join(setClauses, ", ") + " WHERE " + strings.Join(whereClauses, " AND ")
  return query, values
}
EOF


# UF UF UF :O
# DB CONFIG MUY MUY NECESARIA
echo "üìÑ Generando pkg/config/db.go (Conexi√≥n a DB)..."
cat <<EOF > pkg/config/db.go
package config

import (
  "database/sql"
  "fmt"
  "log"
  "os"

  "github.com/joho/godotenv" // La mantengo por si se ejecuta SIN Docker

  _ "github.com/lib/pq"
)

var db *sql.DB

// ConnectDB establece la conexi√≥n a la base de datos.
func ConnectDB() {
  // Solo cargamos el .env si no estamos en un entorno Dockerizado o si falta la variable clave.
  // En Docker Compose, las variables ya son inyectadas por el 'env_file' en docker-compose.yml.
  if os.Getenv("IN_DOCKER") != "true" {
      if err := godotenv.Load(); err != nil {
          log.Println("Advertencia: No se pudo cargar .env. Asumiendo variables de entorno preexistentes.")
      }
  }

  // Usar la variable DB_URL del .env / entorno
  dbURL := os.Getenv("DB_URL")
  if dbURL == "" {
    // Si falla, significa que la inyecci√≥n de Docker o el archivo .env fallaron
    log.Fatal("Error: La variable DB_URL no est√° configurada en el entorno.")
  }
  var err error

  db, err = sql.Open("postgres", dbURL) 
  if err != nil {

    log.Fatalf("Error al abrir conexi√≥n con DB (%s): %v", dbURL, err)
  }

  if err = db.Ping(); err != nil {
    log.Fatalf("Error al hacer Ping a la DB. %v", err)
  }

  fmt.Println("‚úÖ Conectado a la base de datos exitosamente.")
}
// RETORNA UNA FUNCION QUE DEVUELVE LA CONEXI√ìN A LA BASE DE DATOS
func GetDB() *sql.DB {
  if db == nil {
    log.Fatal("Error: La conexi√≥n a la base de datos no ha sido establecida.")
  }
  return db
}
EOF

echo "üìÑ Generando cmd/server/main.go (Punto de entrada)..."
# main.go ES EL PUNTO DE ENTRADA DE LA APLICACI√ìN
# AQUI SE CONECTA A LA BASE DE DATOS, SE INICIALIZA FIBER Y SE LEVANTA EL SERVIDOR
# AQUI PUEDES AGREGAR RUTAS, MIDDLEWARES, ETC
# POR AHORA SOLO TENGO UNA RUTA DE SALUD BASICA
cat <<EOF > cmd/server/main.go
package main

import (
  "fmt"
  "$PROJECT_NAME/pkg/config"
  "log"
  "os"
  

  "github.com/gofiber/fiber/v2"
  _ "github.com/lib/pq"
)

func main() {
  config.ConnectDB()

  // CERRAR LA CONEXI√ìN A LA DB AL SALIR
  defer func() {
    // db.Close() es bloqueante y no acepta contexto, por lo que simplificamos.
    if err := config.GetDB().Close(); err != nil {
      log.Printf("Error al cerrar la conexi√≥n a DB: %v", err)
    } else {
      fmt.Println("Conexi√≥n a DB cerrada.")
    }
  }()


  app := fiber.New()

  // RUTA DE SALUD
  app.Get("/", func(c *fiber.Ctx) error {
    return c.Status(fiber.StatusOK).JSON(fiber.Map{
      "message": "API de $PROJECT_NAME en l√≠nea!",
      "status":  "ok",
    })
  })

  port := os.Getenv("PORT")
  if port == "" {
    port = "8080" 
  }
  log.Printf("üåç Servidor escuchando en el puerto: %s", port)
  log.Fatal(app.Listen(":" + port))
}

EOF

# ==================================
# 5. CONFIGURACI√ìN DE AIR
# ==================================

echo "üîß Configurando Air para Hot Reload..."
if ! command -v air &> /dev/null
then
    echo "‚ùå Air no est√° instalado."
    read -rp "¬øQuieres instalar Air ahora? (y/n): " choice
    if [[ "$choice" == "y" || "$choice" == "Y" ]]; then
        echo "üîß Instalando Air..."
        go install github.com/air-verse/air@latest
        echo "‚úÖ Air instalado."
    else
        echo "‚ö†Ô∏è Air no se instalar√°. Deber√°s compilar manualmente."
    fi
else
    echo "‚úÖ Air ya est√° instalado."
fi

# CONFIGURA AIR TOML YA QUE LA CONFIGURACION POR DEFECTO NO SIRVE
# SI AIR NO ESTA INSTALADO, ESTA PARTE NO HARA NADA
# EL ARCHIVO .AIR.TOML ESTA CONFIGURADO PARA QUE SOLO RECONOZCA CAMBIOS EN EL BACKEND
# Y NO EN COSAS COMO EL DOCKERFILE, COMPOSE, ETC
# ASI NO SE REINICIA EL SERVIDOR INNECESARIAMENTE
# SI QUIERES MODIFICARLO, PUEDES HACERLO DESPUES DE QUE EL SCRIPT TERMINE
# OJO: SI MODIFICAS LA ESTRUCTURA DE DIRECTORIOS, DEBES ACTUALIZAR ESTO
# YA QUE SI NO, AIR NO DETECTARA LOS CAMBIOS
air init > /dev/null 2>&1
cat <<EOF > .air.toml
root = "."
testdata_dir = "testdata"
tmp_dir = "tmp"


[build]
  args_bin = []
  bin = "./tmp/main"
  cmd = "go build -o ./tmp/main ./cmd/server"
  delay = 1000
  exclude_dir = ["assets", "tmp", "vendor", "testdata"]
  exclude_file = []
  exclude_regex = ["_test.go"]
  exclude_unchanged = false
  follow_symlink = false
  full_bin = ""
  include_dir = ["cmd/server", "internal", "pkg"]
  include_ext = ["go", "tpl", "tmpl", "html"]
  include_file = []
  kill_delay = "0s"
  log = "build-errors.log"
  poll = false
  poll_interval = 0
  post_cmd = []
  pre_cmd = []
  rerun = false
  rerun_delay = 500
  send_interrupt = false
  stop_on_error = false

[color]
  app = ""
  build = "yellow"
  main = "magenta"
  runner = "green"
  watcher = "cyan"

[log]
  main_only = false
  silent = false
  time = false

[misc]
  clean_on_exit = false

[proxy]
  app_port = 0
  enabled = false
  proxy_port = 0

[screen]
  clear_on_rebuild = false
  keep_scroll = true
EOF
# ESTE SCRIPT ES DE USO LIBRE, ASI QUE PUEDES MODIFICARLO A TU GUSTO
# SI TIENES ALGUNA SUGERENCIA, PUEDES CONTACTARME EN github.com/Nn3z o en https://www.linkedin.com/in/pablo-ponce-82ab61379/